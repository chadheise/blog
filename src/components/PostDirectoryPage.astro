---
import Nav from "./Nav.astro";
import PostList from "./PostList.astro";
import Tag from "./Tag.astro";
import Footer from "./Footer.astro";
import { parseAndSortBlogPosts, parseAndSortProjectPosts } from "../lib/post";

interface Props {
  title: string;
  directory: "blog" | "projects";
}

const { title, directory } = Astro.props as Props;

const allPosts =
  directory === "blog"
    ? await parseAndSortBlogPosts()
    : await parseAndSortProjectPosts();

// Collect unique tags present across all posts in this directory
const tagSet = new Set<string>();
for (const post of allPosts) {
  for (const tag of post.frontmatter.tags ?? []) {
    tagSet.add(tag);
  }
}
const uniqueTags = [...tagSet].sort((a, b) => a.localeCompare(b));
---

<div class="directory-page">
  <div class="sticky-header">
    <Nav backLink={{ href: "/", label: "Home" }} />
    <h1 class="directory-title">{title}</h1>

    <div class="filter-section" id="filter-section">
      <div class="filter-header">
        <p class="filter-label">Filter by tag:</p>
        <Tag as="button" label="All" selected={true} dataTag="__all__" />
        <Tag as="button" label="None" selected={false} dataTag="__none__" />
      </div>
      <div
        class="filter-tags"
        id="filter-tags"
        data-all-tags={JSON.stringify(uniqueTags.map((t) => t.toLowerCase()))}
      >
        {
          uniqueTags.map((tag) => (
            <Tag
              as="button"
              label={tag}
              selected={true}
              dataTag={tag.toLowerCase()}
            />
          ))
        }
      </div>
    </div>
  </div>

  <PostList directory={directory} />
  <Footer />
</div>

<script>
  const filterContainer = document.getElementById("filter-tags");
  if (filterContainer) {
    const allTagsData: string[] = JSON.parse(
      filterContainer.dataset.allTags || "[]",
    );
    const selectedTags = new Set<string>(allTagsData);

    const filterSection = filterContainer.closest(".filter-section");
    const filterButtons = (
      filterSection ?? filterContainer
    ).querySelectorAll<HTMLButtonElement>("button[data-tag]");
    const postCards =
      document.querySelectorAll<HTMLAnchorElement>(".post-card");

    // Hide filter section on scroll down, show on scroll up (mobile only)
    const filterEl = document.getElementById("filter-section");
    if (filterEl) {
      let lastScrollY = window.scrollY;
      window.addEventListener("scroll", () => {
        // Only apply on mobile breakpoint
        if (window.innerWidth > 600) return;
        const currentScrollY = window.scrollY;
        const maxScroll =
          document.documentElement.scrollHeight - window.innerHeight;
        const upDelta = lastScrollY - currentScrollY;
        if (currentScrollY > lastScrollY && currentScrollY > 40) {
          filterEl.classList.add("filter-hidden");
        } else if (upDelta >= 10 && lastScrollY <= maxScroll + 1) {
          // Require at least 10px of upward movement before showing.
          // This ignores the small oscillations from the bottom bounce (typically 1-5px),
          // while still responding naturally to intentional upward scrolling.
          // Also guard against overscroll bounce where lastScrollY exceeded maxScroll.
          filterEl.classList.remove("filter-hidden");
        }
        lastScrollY = currentScrollY;
      }, { passive: true });
    }

    function updatePostVisibility() {
      postCards.forEach((card) => {
        const cardTags: string[] = JSON.parse(card.dataset.tags || "[]");
        // Posts with no tags always show; others show if any selected tag matches
        const visible =
          cardTags.length === 0 || cardTags.some((t) => selectedTags.has(t));
        card.style.display = visible ? "" : "none";
      });
    }

    function updateButtonStates() {
      filterButtons.forEach((btn) => {
        const tag = btn.dataset.tag;
        let isSelected: boolean;
        if (tag === "__all__") {
          isSelected = allTagsData.every((t) => selectedTags.has(t));
        } else if (tag === "__none__") {
          isSelected = selectedTags.size === 0;
        } else {
          isSelected = selectedTags.has(tag!);
        }
        btn.classList.toggle("selected", isSelected);
      });
    }

    filterButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const tag = btn.dataset.tag;
        if (tag === "__all__") {
          allTagsData.forEach((t) => selectedTags.add(t));
        } else if (tag === "__none__") {
          selectedTags.clear();
        } else if (tag) {
          if (selectedTags.has(tag)) {
            selectedTags.delete(tag);
          } else {
            selectedTags.add(tag);
          }
        }
        updateButtonStates();
        updatePostVisibility();
      });
    });

    // Set initial state
    updateButtonStates();
    updatePostVisibility();
  }
</script>

<style>
  .directory-page {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem 1.5rem;
    min-height: 100vh;
  }

  .sticky-header {
    position: sticky;
    top: 0;
    z-index: 10;
    background-color: var(--color-bg);
    padding-bottom: 1rem;
  }

  /* Nav manages its own sticky; disable it inside the sticky-header wrapper */
  .sticky-header :global(.site-nav) {
    position: static;
    margin-bottom: 0;
  }

  .directory-title {
    font-size: 2rem;
    color: var(--color-accent);
    margin-bottom: 0;
  }

  .filter-section {
    margin-top: 1rem;
  }

  .filter-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .filter-label {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin: 0;
  }

  .filter-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  @media (max-width: 600px) {
    .directory-page {
      padding: 1.5rem 1rem;
    }

    .directory-title {
      font-size: 1.5rem;
    }

    .filter-section {
      overflow: hidden;
      max-height: 200px;
      opacity: 1;
      transition:
        max-height 0.25s ease,
        opacity 0.25s ease,
        margin-top 0.25s ease;
    }

    .filter-section.filter-hidden {
      max-height: 0;
      opacity: 0;
      margin-top: 0;
    }
  }
</style>
